# 로프 문제

문제 번호: 2217
알고리즘 분류: 정렬
푼 날짜: 2021년 1월 24일 오후 8:24

### 문제 링크

[https://www.acmicpc.net/problem/2217](https://www.acmicpc.net/problem/2217)

## 문제

N(1 ≤ N ≤ 100,000)개의 로프가 있다. 이 로프를 이용하여 이런 저런 물체를 들어올릴 수 있다. 각각의 로프는 그 굵기나 길이가 다르기 때문에 들 수 있는 물체의 중량이 서로 다를 수도 있다.

하지만 여러 개의 로프를 병렬로 연결하면 각각의 로프에 걸리는 중량을 나눌 수 있다. k개의 로프를 사용하여 중량이 w인 물체를 들어올릴 때, 각각의 로프에는 모두 고르게 w/k 만큼의 중량이 걸리게 된다.

각 로프들에 대한 정보가 주어졌을 때, 이 로프들을 이용하여 들어올릴 수 있는 물체의 최대 중량을 구해내는 프로그램을 작성하시오. 모든 로프를 사용해야 할 필요는 없으며, 임의로 몇 개의 로프를 골라서 사용해도 된다.

## 입력

첫째 줄에 정수 N이 주어진다. 다음 N개의 줄에는 각 로프가 버틸 수 있는 최대 중량이 주어진다. 이 값은 10,000을 넘지 않는 자연수이다.

## 출력

첫째 줄에 답을 출력한다.

## 조건

- 시간 제한 : 2s
- 메모리 제한 : 192MB

---

## 해설

로프에 걸리는 무게가 w/k 이므로, (선택한 로프 중 최저 중량) x (로프 개수) 가 들 수 있는 무게의 최대 중량과 같다. 로프를 중량 순으로 정렬한 뒤, 가장 작은 중량부터 하나씩 제외하면서 들 수 있는 중량을 확인한다. 이 중 가장 무거운 중량을 출력한다.

## 풀이

처음에 든 생각은 다음과 같았다. 어차피 로프 중량은 정렬되어 있으니까, 중량의 합이 한 번 올라갔다가 내려오면 그 지점이 최대 중량이 아닐까? 그래서 아래처럼 sum이 한 번 최고점을 찍고 그 다음 중량이 떨어지면 반복문을 탈출하게 코드를 작성했다.

```cpp
sort(arr, arr+N);

for(int i = 0; i < N; i++) {
    if(sum < arr[i] * (N-i)) {
        sum = arr[i] * (N-i);
    } 
    else {
        break;
    }
}
```

그런데, 오답이라고 나오더라. 반례를 생각해봤는데, 1 2 3 4 100 의 경우 중량이 5 8 9 8 100 이지만, 내가 작성한 코드대로면 9가 최댓값으로 뽑히게 된다. 모든 원소를 끝까지 살펴봐야지 알 수 있기에 아래와 같이 코드를 수정했다.

```cpp
sort(arr, arr+N);

for(int i = 0; i < N; i++) {
    if(sum < arr[i] * (N-i)) {
        sum = arr[i] * (N-i);
    } 
}
```

---

## 코멘트

문제는 잘못 없고, 내가 잘못했더라...

---

## 코드

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int main() {
    int N;
    int sum=0; 
    int* arr;
    
    scanf("%d", &N);
    arr = new int[N];
    
    for(int i = 0; i < N; i++) {
        scanf("%d", &arr[i]);
    }
    
    sort(arr, arr+N);
    
    for(int i = 0; i < N; i++) {
        if(sum < arr[i] * (N-i)) {
            sum = arr[i] * (N-i);
        } 
        // else {
        //     break;
        // }
    }
    
    printf("%d", sum);
    return 0;
}
```